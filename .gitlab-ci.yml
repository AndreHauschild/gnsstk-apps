#.yml file for Gitlab-CI support

# Note that the following tokens must be supplied via the Gitlab Repository Settings:
# - CI_USER: username to pull from gitlab repository in sgl-tks group
# - CI_TOKEN: password to pull from gitlab repository in sgl-tks group
# - PACKAGE_CONFIG_1/2 to pull from project settings cicd variables
# - PACKAGE_CONFIG_CONDA_1/2 to pull from project settings cicd variables
# - DOCKER_REGISTRY to pull from project settings cicd variables

include:
  - project: sgl-tks/ci-control
    file: /gnsstk-apps/ci_downstrm_chain.yml
    ref: main
  - project: sgl-tks/ci-control
    file: /general/artifactory-upload.yml
    ref: main
  - project: 'sgl/ci-control'
    file: 'common/scanning/sonar.yml'

stages:
  - check
  - build
  - test
  - quality
  - install
  - package
  - push
  - deploy
  - downstream_stack
  - experiment

variables:
  # Default cmake arguments
  CMAKE_ARG_DEFAULT: "-DBUILD_EXT=ON -DTEST_SWITCH=ON ../"
  GNSSTK_COMMIT:
    value: "main"
    description: "Upstream gnsstk lib branch to link. Defaults to main"
  # By default, pipeline will build with both VS 2015 and VS 2019 windows jobs along with rest of platform jobs.
  # If you want to build only VS 2019 windows jobs, then set BLD_ONLY_VS2019 to True. It will exclude rest of platform jobs.
  # If you want to exclude VS 2019 windows jobs, then set BLD_VS2019 to False.
  BLD_VS2019:
    value: "True"
    description: "If True, then build under Windows using Visual Studio 2019. Defaults to True"
  BLD_ONLY_VS2019:
    value: "False"
    description: "If True, then ONLY build Windows using Visual Studio 2019 and skips Visual Studio 2015 jobs. Defaults to False"
  BLD_VS_DLL:
    value: "True"
    description: "If True, then link against Dynamic Link Libraries (VS2019 only)"
  BLD_VS_STATIC:
    value: "True"
    description: "If True, then link against Static Libraries (VS2019 only, VS2015 always builds static)"

  # Sonar Controls
  SONAR_EXCLUSIONS: '**/tests/**,**/rpm_files/**,**/conda_recipe/**,**/data/**,**/coverage-cpp.xml,**/build*/**,**/debian/**,**/deprecated/**,**/examples/**,**/ref/**,**/rpm_files/**,**/swig/**,**/DoxygenLayout.xml,**/custom.css'
  SONAR_SOURCES: 'core'
  SONAR_TEST_SOURCES: 'core/tests'
  SONAR_TEST_INCLUSION: 'core/tests'
  SONAR_PROJECT_KEY: gnsstk-apps
  SONAR_ADDTIONAL_PARAMS: "-Dsonar.cfamily.gcov.reportsPath=."

# Template for all normal jobs.
.normal_job:
  except:
    variables:
      - $BLD_ONLY_VS2019 == "True"

.vs2019_job:
  only:
    variables:
      - $BLD_VS2019 == "True"
      - $BLD_VS_STATIC == "True"

.vs2019_dll_job:
  only:
    variables:
      - $BLD_VS2019 == "True"
      - $BLD_VS_DLL == "True"

# Template for all jobs that should deploy packages.
.package_deploy:
  only:
    refs:
      - main
      - /^ci_.*$/
      - /^version_.*_prep$/
      - tags
      - /^tag_.*$/
      - stable
      - /^release\/v[0-9.]*$/
      - /^bugfix/ci_*$/
      - /^feature/ci_*$/
    variables:
      - $BLD_ONLY_VS2019 != "True"

.build_conda:
  stage: build
  needs: []
  extends: .normal_job
  tags:
    - docker-executor
  image: $DOCKER_REGISTRY/tks/centos-conda:python-3.6
  before_script:
    - source /opt/miniconda/etc/profile.d/conda.sh
  script:
    # Install dependencies from latest CI first. Some packages are python version dependent, others are not.
    # Using python 3.9 for build and testing is arbitrary since gnsstk-apps is not python dependent.
    - bash conda_recipe/get_required_deps_conda.sh package_conda ${PKG_TYPE} 
    - 'bash conda_recipe/get_required_deps_conda.sh "package_conda: [3.9]" ${PKG_TYPE}'
    - conda create -c file://$PWD/conda-deps --name py3.9 "python=3.9" gnsstk ${OPT_CONDA_LIBS}
    - conda activate py3.9
    # Link optional libraries
    - ./optional_package_add.sh ${OPT_LIBS}
    - mkdir -p build
    - cd build
    - export gnsstk=`pwd`/install
    - cmake -DPYTHON_INSTALL_PREFIX=$gnsstk -DCMAKE_INSTALL_PREFIX=install $CMAKE_ARG_DEFAULT
    - make all -j 4
  artifacts:
    paths:
      - build/

# Check Stage
# Runs static analysis on code.
static_analysis:
  stage: check
  needs: []
  extends: .normal_job
  tags:
    - docker-executor
  image: $DOCKER_REGISTRY/sgl/debian-10:pkgbuild
  script:
    - ./lint_test.sh
  # Allow failures here to prevent blocking the rest of the pipeline.
  allow_failure: true

submodule_check:
  stage: check
  needs: []
  extends: .normal_job
  tags:
    - docker-executor
  variables:
    GIT_SUBMODULE_UPDATE_FLAGS: --remote
  only:
    - main
  image: $DOCKER_REGISTRY/sgl/debian-10:pkgbuild
  script:
    - (! git status --porcelain | grep 'M data')

# sgl_lint will verify that source files have proper copyright.
sgllint_lint:
  stage: check
  needs: []
  extends: .normal_job
  tags:
    - docker-executor
  image: $DOCKER_REGISTRY/sgl/debian-10:python3
  script:
    - '######'
    - '# This job checks all files for required lines like copyright/license statements.'
    - '######'
    # Obtain the latest version of ./sgl_lint.py
    - python3 -m pip install sgl-ci-tools
    - sgl_lint -v -R core
    - sgl_lint -v -R ext
    - sgl_lint -v -R swig/apps
    - sgl_lint -v -R swig/gnsstk
  dependencies: []

protected_term_lint:
  stage: check
  needs: []
  extends: .normal_job
  tags:
    - docker-executor
  image: $DOCKER_REGISTRY/sgl/debian-10:python3
  script:
    - '######'
    - '# This job checks all files for protected terms in files modified since the branch split from default.'
    - '######'
    - apt-get update && apt-get install -y git
    - python3 -m pip install tks-ci-tools
    # We pull the default branch because the CI doesn't normally have any branches other than the one being tested.
    - echo "git fetch -uf origin ${CI_DEFAULT_BRANCH}:${CI_DEFAULT_BRANCH}"
    - git fetch -uf origin ${CI_DEFAULT_BRANCH}:${CI_DEFAULT_BRANCH}
    - echo "modified_file_check.sh ${CI_DEFAULT_BRANCH} $CI_COMMIT_SHA"
    - modified_file_check.sh ${CI_DEFAULT_BRANCH} $CI_COMMIT_SHA
  dependencies: []
  # This has the occasional false-positive, so it's advisory only.
  allow_failure: true

protected_history_lint:
  stage: check
  needs: []
  extends: .normal_job
  tags:
    - docker-executor
  image: $DOCKER_REGISTRY/sgl/debian-10:python3
  script:
    - '######'
    - '# This job checks all files modified on this branch for sensitive terms.'
    - '######'
    - apt-get update && apt-get install -y git
    - python3 -m pip install tks-ci-tools
    # We pull the default branch because the CI doesn't normally have any branches other than the one being tested.
    - echo "git fetch -uf origin ${CI_DEFAULT_BRANCH}:${CI_DEFAULT_BRANCH}"
    - git fetch -uf origin ${CI_DEFAULT_BRANCH}:${CI_DEFAULT_BRANCH}
    - echo "history_check.sh ${CI_DEFAULT_BRANCH} $CI_COMMIT_SHA"
    - history_check.sh ${CI_DEFAULT_BRANCH} $CI_COMMIT_SHA
  dependencies: []
  # This has the occasional false-positive, so it's advisory only.
  allow_failure: true

# Runs the documentation generation
generate_documentation:
  stage: check
  needs: []
  extends: .normal_job
  tags:
    - docker-executor
  image: $DOCKER_REGISTRY/sgl/debian-10:pkgbuild
  script:
    # Install GraphViz
    - sudo apt-get install -y graphviz
    # Call doxygen w/alternate target directory
    - doxygen
  # Allow failures here to prevent blocking the rest of the pipeline.
  allow_failure: true
  artifacts:
    paths:
      - docs/

# Validates some internal repository structure.
repository_validation:
  stage: check
  needs: []
  extends: .normal_job
  tags:
    - docker-executor
  image: $DOCKER_REGISTRY/sgl/debian-10:pkgbuild
  script:
    # Verify there are no duplicate header files names in the repo.
    - ./dup_check.sh
  # Allow failures here to prevent blocking the rest of the pipeline.
  allow_failure: false

#
# Build Stage - Try building in several environments.
#
deb10_build:
  stage: build
  needs: []
  extends: .normal_job
  tags:
    - docker-executor
  image: $DOCKER_REGISTRY/sgl/debian-10:pkgbuild
  script:
    # Install dependencies from latest CI first.
    - bash debian/install_required_deps_debian.sh package_debian_10 pkg_min
    # source gnsstk's post install script to set private library install env variables.
    - source /usr/share/gnsstk*/gnsstk_post_install.sh
    - mkdir -p build
    - cd build
    - cmake -DCMAKE_INSTALL_PREFIX=install -DPYTHON_EXECUTABLE=/usr/bin/python3 $CMAKE_ARG_DEFAULT
    - make all -j 4
  artifacts:
    paths:
      - build/

deb10_op1_build:
  stage: build
  needs: []
  extends: .normal_job
  tags:
    - docker-executor
  image: $DOCKER_REGISTRY/sgl/debian-10:pkgbuild
  script:
    # Install dependencies from latest CI first.
    - bash debian/install_required_deps_debian.sh package_debian_10 pkg_max
    # source gnsstk's and optional dependencies' post install script to set private library install env variables.
    - source /usr/share/gnsstk*/gnsstk_post_install.sh
    - for tks in ${PACKAGE_CONFIG_2}; do source /usr/share/${tks}*/${tks}_post_install.sh; done
    # Link optional library
    - ./optional_package_add.sh $PACKAGE_CONFIG_1
    - mkdir -p build
    - cd build
    - cmake -DCMAKE_INSTALL_PREFIX=install -DPYTHON_EXECUTABLE=/usr/bin/python3 $CMAKE_ARG_DEFAULT
    - make all -j 4
  artifacts:
    paths:
      - build/

deb10_op2_build:
  stage: build
  needs: []
  extends: .normal_job
  tags:
    - docker-executor
  image: $DOCKER_REGISTRY/sgl/debian-10:pkgbuild
  script:
    # Install dependencies from latest CI first.
    - bash debian/install_required_deps_debian.sh package_debian_10 pkg_max
    # source gnsstk's and optional dependencies' post install script to set private library install env variables.
    - source /usr/share/gnsstk*/gnsstk_post_install.sh
    - for tks in ${PACKAGE_CONFIG_2}; do source /usr/share/${tks}*/${tks}_post_install.sh; done
    # Link optional libraries
    - ./optional_package_add.sh $PACKAGE_CONFIG_2
    - mkdir -p build
    - cd build
    - cmake -DCMAKE_INSTALL_PREFIX=install -DPYTHON_EXECUTABLE=/usr/bin/python3 $CMAKE_ARG_DEFAULT
    - make all -j 4
  artifacts:
    paths:
      - build/

deb11_build:
  stage: build
  needs: []
  extends: .normal_job
  tags:
    - docker-executor
  image: $DOCKER_REGISTRY/sgl/debian-11:pkgbuild
  script:
    # Install dependencies from latest CI first.
    - bash debian/install_required_deps_debian.sh package_debian_11 pkg_min
    # source gnsstk's post install script to set private library install env variables.
    - source /usr/share/gnsstk*/gnsstk_post_install.sh
    - mkdir -p build
    - cd build
    - cmake -DCMAKE_INSTALL_PREFIX=install $CMAKE_ARG_DEFAULT
    - make all -j 4
  artifacts:
    paths:
      - build/

deb11_op1_build:
  stage: build
  needs: []
  extends: .normal_job
  tags:
    - docker-executor
  image: $DOCKER_REGISTRY/sgl/debian-11:pkgbuild
  script:
    # Install dependencies from latest CI first.
    - apt-get install -y libhdf5-dev
    - bash debian/install_required_deps_debian.sh package_debian_11 pkg_max
    # source gnsstk's and optional dependencies' post install script to set private library install env variables.
    - source /usr/share/gnsstk*/gnsstk_post_install.sh
    - for tks in ${PACKAGE_CONFIG_2}; do source /usr/share/${tks}*/${tks}_post_install.sh; done
    # Link optional libraries
    - ./optional_package_add.sh $PACKAGE_CONFIG_1
    - mkdir -p build
    - cd build
    - cmake -DCMAKE_INSTALL_PREFIX=install $CMAKE_ARG_DEFAULT
    - make all -j 4
  artifacts:
    paths:
      - build/

deb11_op2_build:
  stage: build
  needs: []
  extends: .normal_job
  tags:
    - docker-executor
  image: $DOCKER_REGISTRY/sgl/debian-11:pkgbuild
  script:
    # Install dependencies from latest CI first.
    - apt-get install -y libhdf5-dev
    - bash debian/install_required_deps_debian.sh package_debian_11 pkg_max
    # source gnsstk's and optional dependencies' post install script to set private library install env variables.
    - source /usr/share/gnsstk*/gnsstk_post_install.sh
    - for tks in ${PACKAGE_CONFIG_2}; do source /usr/share/${tks}*/${tks}_post_install.sh; done
    # Link optional libraries
    - ./optional_package_add.sh $PACKAGE_CONFIG_2
    - mkdir -p build
    - cd build
    - cmake -DCMAKE_INSTALL_PREFIX=install $CMAKE_ARG_DEFAULT
    - make all -j 4
  artifacts:
    paths:
      - build/

ubu20_build:
  stage: build
  needs: []
  extends: .normal_job
  tags:
    - docker-executor
  image: $DOCKER_REGISTRY/sgl/ubuntu-20.04:pkgbuild
  script:
    # Install dependencies from latest CI first.
    - bash debian/install_required_deps_debian.sh package_ubuntu_20.04 pkg_min
    # source gnsstk's post install script to set private library install env variables.
    - source /usr/share/gnsstk*/gnsstk_post_install.sh
    - mkdir -p build
    - cd build
    - cmake -DCMAKE_INSTALL_PREFIX=install -DPYTHON_EXECUTABLE=/usr/bin/python3 $CMAKE_ARG_DEFAULT
    - make all -j 4
  artifacts:
    paths:
      - build/

conda_build:
  variables:
    OPT_LIBS: ""
    OPT_CONDA_LIBS: ""
    PKG_TYPE: "pkg_min"
  extends: .build_conda

conda_op2_build:
  variables:
    OPT_LIBS: $PACKAGE_CONFIG_2
    OPT_CONDA_LIBS: $PACKAGE_CONFIG_CONDA_2
    PKG_TYPE: "pkg_max"
  extends: .build_conda

rhel8_build:
  stage: build
  needs: []
  extends: .normal_job
  tags:
    - docker-executor
  image: $DOCKER_REGISTRY/sgl/centos-8:pkgbuild
  script:
    # Install dependencies from latest CI first.
    - bash rpm_files/install_required_deps_rpm.sh package_redhat_8 pkg_min
    - mkdir -p build
    - cd build
    - cmake -DCMAKE_INSTALL_PREFIX=install $CMAKE_ARG_DEFAULT
    - make all -j 4
  artifacts:
    paths:
      - build/

windows_build:
  variables:
    GIT_CLONE_PATH: $CI_BUILDS_DIR/$CI_PROJECT_NAME/$CI_PIPELINE_ID
  stage: build
  needs: []
  extends: .normal_job
  tags:
    - win10-vs2015
  script:
    - windows/install_required_deps_windows.ps1 user_install_windows pkg_min
    - Get-ChildItem "$env:CI_PROJECT_DIR\library\build\install\share\cmake" -Directory | Foreach-Object { $env:CMAKE_PREFIX_PATH += ";" + $_.FullName }
    - mkdir build
    - cd build
    - cmake -DCMAKE_INSTALL_PREFIX=install -DBUILD_EXT=ON -DTEST_SWITCH=ON -G "Visual Studio 14 2015 Win64" ../
    - cmake --build . --config Release -- /m
  artifacts:
    paths:
    - build/

windows_build_vs2019:
  variables:
    GIT_CLONE_PATH: $CI_BUILDS_DIR/$CI_PROJECT_NAME/${CI_PIPELINE_ID}_vs2019
  stage: build
  needs: []
  extends: .vs2019_job
  tags:
    - win10-vs2019
  script:
    - windows/install_required_deps_windows.ps1 user_install_windows_vs2019 pkg_min
    - Get-ChildItem "$env:CI_PROJECT_DIR\library\build\install\share\cmake" -Directory | Foreach-Object { $env:CMAKE_PREFIX_PATH += ";" + $_.FullName }
    - mkdir build
    - cd build
    - cmake -DBUILD_SHARED_LIBS=FALSE -DCMAKE_INSTALL_PREFIX=install -DBUILD_EXT=ON -DTEST_SWITCH=ON -G "Visual Studio 16 2019" -A x64 ../
    - cmake --build . --config Release  -- /m
  artifacts:
    paths:
    - build/
  allow_failure: false

windows_build_vs2019_dll:
  variables:
    GIT_CLONE_PATH: $CI_BUILDS_DIR/$CI_PROJECT_NAME/${CI_PIPELINE_ID}_vs2019_dll
  stage: build
  needs: []
  extends: .vs2019_dll_job
  tags:
    - win10-vs2019
  script:
    - windows/install_required_deps_windows.ps1 user_install_windows_vs2019_dll pkg_min
    - Get-ChildItem "$env:CI_PROJECT_DIR\library\build\install\share\cmake" -Directory | Foreach-Object { $env:CMAKE_PREFIX_PATH += ";" + $_.FullName }
    - mkdir build
    - cd build
    - cmake -DBUILD_SHARED_LIBS=TRUE -DCMAKE_INSTALL_PREFIX=install -DBUILD_EXT=ON -DTEST_SWITCH=ON -G "Visual Studio 16 2019" -A x64 ../
    - cmake --build . --config Release  -- /m
  artifacts:
    paths:
    - build/
  allow_failure: false

windows_op1_build_vs2019:
  variables:
    GIT_CLONE_PATH: $CI_BUILDS_DIR/$CI_PROJECT_NAME/${CI_PIPELINE_ID}_vs2019_op1
  stage: build
  needs: []
  extends: .vs2019_job
  tags:
    - win10-vs2019
  script:
    - $linkfile=".\ExtLinkage.cmake"
    - $str1="find_package("
    - $str2=$env:PACKAGE_CONFIG_1.ToUpper()
    - $str3=" CONFIG)"
    - if (Test-Path $linkfile) { Remove-Item $linkfile }
    - foreach ($pkg in $str2) { "$str1$pkg$str3" | Out-File -FilePath $linkfile -Append -Encoding UTF8 }
    - type $linkfile
    - windows/install_required_deps_windows.ps1 user_install_windows_vs2019 pkg_max
    - Get-ChildItem "$env:CI_PROJECT_DIR\library\build\install\share\cmake" -Directory | Foreach-Object { $env:CMAKE_PREFIX_PATH += ";" + $_.FullName }
    - mkdir build
    - cd build
    - cmake -DBUILD_SHARED_LIBS=FALSE -DCMAKE_INSTALL_PREFIX=install -DBUILD_EXT=ON -DTEST_SWITCH=ON -G "Visual Studio 16 2019" -A x64 ../
    - cmake --build . --config Release  -- /m
  artifacts:
    paths:
    - build/
  allow_failure: false

windows_op1_build_vs2019_dll:
  variables:
    GIT_CLONE_PATH: $CI_BUILDS_DIR/$CI_PROJECT_NAME/${CI_PIPELINE_ID}_vs2019_dll_op1
  stage: build
  needs: []
  extends: .vs2019_dll_job
  tags:
    - win10-vs2019
  script:
    - $linkfile=".\ExtLinkage.cmake"
    - $str1="find_package("
    - $str2=$env:PACKAGE_CONFIG_1.ToUpper()
    - $str3=" CONFIG)"
    - if (Test-Path $linkfile) { Remove-Item $linkfile }
    - foreach ($pkg in $str2) { "$str1$pkg$str3" | Out-File -FilePath $linkfile -Append -Encoding UTF8 }
    - type $linkfile
    - windows/install_required_deps_windows.ps1 user_install_windows_vs2019_dll pkg_max
    - Get-ChildItem "$env:CI_PROJECT_DIR\library\build\install\share\cmake" -Directory | Foreach-Object { $env:CMAKE_PREFIX_PATH += ";" + $_.FullName }
    - mkdir build
    - cd build
    - cmake -DBUILD_SHARED_LIBS=TRUE -DCMAKE_INSTALL_PREFIX=install -DBUILD_EXT=ON -DTEST_SWITCH=ON -G "Visual Studio 16 2019" -A x64 ../
    - cmake --build . --config Release  -- /m
  artifacts:
    paths:
    - build/
  allow_failure: false

.test_conda:
  stage: test
  extends: .normal_job
  tags:
    - docker-executor
  image: $DOCKER_REGISTRY/tks/centos-conda:python-3.6
  before_script:
    - source /opt/miniconda/etc/profile.d/conda.sh
  script:
    # Install dependencies from latest CI first. Some dependencies are python version dependent, others are not.
    - bash conda_recipe/get_required_deps_conda.sh package_conda ${PKG_TYPE} 
    - 'bash conda_recipe/get_required_deps_conda.sh "package_conda: [3.9]" ${PKG_TYPE}'
    - conda create -c file://$PWD/conda-deps/ --name py3.9 python=3.9 gnsstk $OPT_CONDA_LIBS
    - conda activate py3.9
    - python -c "import gnsstk"
    - cd build
    - ctest -j 4
    - touch $CI_PROJECT_DIR/success
  artifacts:
    when: on_failure
    paths:
    - build/Testing/Temporary/
    - build/swig/
    expire_in: 4 days

conda_test:
  extends: .test_conda
  dependencies: [conda_build]
  needs: [conda_build]
  variables:
    OPT_LIBS: ""
    OPT_CONDA_LIBS: ""
    PKG_TYPE: "pkg_min"

conda_op2_test:
  extends: .test_conda
  dependencies: [conda_op2_build]
  needs: [conda_op2_build]
  variables:
    OPT_LIBS: $PACKAGE_CONFIG_2
    OPT_CONDA_LIBS: $PACKAGE_CONFIG_CONDA_2
    PKG_TYPE: "pkg_max"

deb10_test:
  stage: test
  needs: [deb10_build]
  extends: .normal_job
  tags:
    - docker-executor
  image: $DOCKER_REGISTRY/sgl/debian-10:pkgbuild
  script:
    - bash debian/install_required_deps_debian.sh package_debian_10 pkg_min
    # source gnsstk's post install script to set private library install env variables.
    - source /usr/share/gnsstk*/gnsstk_post_install.sh
    - cd build
    - ctest -j 4
  artifacts:
    when: on_failure
    paths:
    - build/Testing/Temporary/
  dependencies:
    - deb10_build

deb10_op2_test:
  stage: test
  needs: [deb10_op2_build]
  extends: .normal_job
  tags:
    - docker-executor
  image: $DOCKER_REGISTRY/sgl/debian-10:pkgbuild
  script:
    - bash debian/install_required_deps_debian.sh package_debian_10 pkg_max
    # source gnsstk's and optional dependencies' post install script to set private library install env variables.
    - source /usr/share/gnsstk*/gnsstk_post_install.sh
    - for tks in ${PACKAGE_CONFIG_2}; do source /usr/share/${tks}*/${tks}_post_install.sh; done
    - cd build
    - ctest -j 4
  artifacts:
    when: on_failure
    paths:
      - build/Testing/Temporary/
  dependencies:
    - deb10_op2_build

deb11_test:
  stage: test
  needs: [deb11_build]
  extends: .normal_job
  tags:
    - docker-executor
  image: $DOCKER_REGISTRY/sgl/debian-11:pkgbuild
  script:
    - bash debian/install_required_deps_debian.sh package_debian_11 pkg_min
    # source gnsstk's post install script to set private library install env variables.
    - source /usr/share/gnsstk*/gnsstk_post_install.sh
    - cd build
    - ctest -j 4
  artifacts:
    when: on_failure
    paths:
    - build/Testing/Temporary/
  dependencies:
    - deb11_build

deb11_op2_test:
  stage: test
  needs: [deb11_op2_build]
  extends: .normal_job
  tags:
    - docker-executor
  image: $DOCKER_REGISTRY/sgl/debian-11:pkgbuild
  script:
    - apt-get install -y libhdf5-dev
    - bash debian/install_required_deps_debian.sh package_debian_11 pkg_max
    # source gnsstk's and optional dependencies' post install script to set private library install env variables.
    - source /usr/share/gnsstk*/gnsstk_post_install.sh
    - for tks in ${PACKAGE_CONFIG_2}; do source /usr/share/${tks}*/${tks}_post_install.sh; done
    - cd build
    - ctest -j 4
  artifacts:
    when: on_failure
    paths:
      - build/Testing/Temporary/
  dependencies:
    - deb11_op2_build

ubu20_test:
  stage: test
  needs: [ubu20_build]
  extends: .normal_job
  tags:
    - docker-executor
  image: $DOCKER_REGISTRY/sgl/ubuntu-20.04:pkgbuild
  script:
    - bash debian/install_required_deps_debian.sh package_ubuntu_20.04 pkg_min
    # source gnsstk's post install script to set private library install env variables.
    - source /usr/share/gnsstk*/gnsstk_post_install.sh
    - cd build
    - ctest -j 4
  artifacts:
    when: on_failure
    paths:
    - build/Testing/Temporary/
  dependencies:
    - ubu20_build

rhel8_test:
  stage: test
  needs: [rhel8_build]
  extends: .normal_job
  tags:
    - docker-executor
  image: $DOCKER_REGISTRY/sgl/centos-8:pkgbuild
  script:
    - bash rpm_files/install_required_deps_rpm.sh package_redhat_8 pkg_min
    - cd build
    - ctest -j 4
  artifacts:
    when: on_failure
    paths:
      - build/Testing/Temporary/
  dependencies:
    - rhel8_build

windows_test:
  variables:
    GIT_CLONE_PATH: $CI_BUILDS_DIR/$CI_PROJECT_NAME/$CI_PIPELINE_ID
    GIT_STRATEGY: none
  stage: test
  needs: [windows_build]
  extends: .normal_job
  tags:
    - win10-vs2015
  script:
    - Get-ChildItem "$env:CI_PROJECT_DIR\library\build\install\share\cmake" -Directory | Foreach-Object { $env:CMAKE_PREFIX_PATH += ";" + $_.FullName }
    - cd build
    - cmake --build . --target RUN_TESTS --config Release
  artifacts:
    when: on_failure
    paths:
    - build/Testing/Temporary/
  dependencies:
    - windows_build
  timeout: 10m
  allow_failure: false

windows_test_vs2019:
  variables:
    GIT_CLONE_PATH: $CI_BUILDS_DIR/$CI_PROJECT_NAME/${CI_PIPELINE_ID}_vs2019
    GIT_STRATEGY: none
  stage: test
  needs: [windows_build_vs2019]
  extends: .vs2019_job
  tags:
    - win10-vs2019
  script:
    - Get-ChildItem "$env:CI_PROJECT_DIR\library\build\install\share\cmake" -Directory | Foreach-Object { $env:CMAKE_PREFIX_PATH += ";" + $_.FullName }
    - cd build
    - cmake --build . --target RUN_TESTS --config Release
  artifacts:
    when: on_failure
    paths:
    - build/Testing/Temporary/
  dependencies:
    - windows_build_vs2019
  timeout: 10m
  allow_failure: false

windows_test_vs2019_dll:
  variables:
    GIT_CLONE_PATH: $CI_BUILDS_DIR/$CI_PROJECT_NAME/${CI_PIPELINE_ID}_vs2019_dll
    GIT_STRATEGY: none
  stage: test
  needs: [windows_build_vs2019_dll]
  extends: .vs2019_dll_job
  tags:
    - win10-vs2019
  script:
    - Get-ChildItem "$env:CI_PROJECT_DIR\library\build\install\share\cmake" -Directory | Foreach-Object { $env:CMAKE_PREFIX_PATH += ";" + $_.FullName }
    - cd build
    - cmake --build . --target RUN_TESTS --config Release
  artifacts:
    when: on_failure
    paths:
    - build/Testing/Temporary/
  dependencies:
    - windows_build_vs2019_dll
  timeout: 10m
  allow_failure: false

windows_op1_test_vs2019:
  variables:
    GIT_CLONE_PATH: $CI_BUILDS_DIR/$CI_PROJECT_NAME/${CI_PIPELINE_ID}_vs2019_op1
    GIT_STRATEGY: none
  stage: test
  needs: [windows_op1_build_vs2019]
  extends: .vs2019_job
  tags:
    - win10-vs2019
  script:
    - Get-ChildItem "$env:CI_PROJECT_DIR\library\build\install\share\cmake" -Directory | Foreach-Object { $env:CMAKE_PREFIX_PATH += ";" + $_.FullName }
    - cd build
    - cmake --build . --target RUN_TESTS --config Release
  artifacts:
    when: on_failure
    paths:
    - build/Testing/Temporary/
  dependencies:
    - windows_op1_build_vs2019
  timeout: 10m
  allow_failure: false

windows_op1_test_vs2019_dll:
  variables:
    GIT_CLONE_PATH: $CI_BUILDS_DIR/$CI_PROJECT_NAME/${CI_PIPELINE_ID}_vs2019_dll_op1
    GIT_STRATEGY: none
  stage: test
  needs: [windows_op1_build_vs2019_dll]
  extends: .vs2019_dll_job
  tags:
    - win10-vs2019
  script:
    - Get-ChildItem "$env:CI_PROJECT_DIR\library\build\install\share\cmake" -Directory | Foreach-Object { $env:CMAKE_PREFIX_PATH += ";" + $_.FullName }
    - cd build
    - cmake --build . --target RUN_TESTS --config Release
  artifacts:
    when: on_failure
    paths:
    - build/Testing/Temporary/
  dependencies:
    - windows_op1_build_vs2019_dll
  timeout: 10m
  allow_failure: false

#
# Quality Stage - SonarQube code quality scan
#

sonar-scan:
  image: $DOCKER_REGISTRY/sgl/debian-11:pkgbuild
  stage: quality
  needs: []
  extends:
    - .sonarqube-check
  tags:
    - docker-executor
  script:
    - apt-get install gcovr lcov -y
    - bash debian/install_required_deps_debian.sh package_debian_11 pkg_min
    - mkdir build
    - cd build
    - cmake -DCMAKE_INSTALL_PREFIX=install -DDEBUG_SWITCH=ON -DTEST_SWITCH=ON -DCOVERAGE_SWITCH=ON ../
    - build-wrapper-linux-x86-64 --out-dir . make all -j 4
    - ctest -j 4
    - cd ..
    - gcovr --exclude=build* --xml-pretty --exclude-unreachable-branches --print-summary -o coverage-cpp.xml -r .
    - for f in `find . -name '*.o'`; do echo "Processing $f file..."; pushd `dirname $f`; gcov -o `basename $f` x; popd ;done
    - !reference [.scan-c++, script]
    - touch $CI_PROJECT_DIR/success
  rules:
    - if: $CI_COMMIT_REF_NAME == "main" || $CI_COMMIT_REF_NAME == "stable"
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: manual
  # Sonar Quality Profile will fail since code coverage is below 80%
  # Allowing job to fail so sonar scan doesn't fail the pipeline for nightly big chain.
  allow_failure: true
  # only:
  #   - merge_requests
  #   - main
  #   - tags
  #   - stable

# User_Install Stage
# Tests user install of GNSSTk on each platform, saves artifacts for
# downstream builds.
deb11_user_install:
  stage: install
  needs: [deb11_build]
  extends: .normal_job
  tags:
    - docker-executor
  image: $DOCKER_REGISTRY/sgl/debian-11:pkgbuild
  script:
    - bash debian/install_required_deps_debian.sh package_debian_11 pkg_min
    # source gnsstk's post install script to set private library install env variables.
    - source /usr/share/gnsstk*/gnsstk_post_install.sh
    - cd build
    - export gnsstk=`pwd`/install
    - cmake -DCMAKE_INSTALL_PREFIX=$gnsstk ../
    - make install -j 4
  artifacts:
    paths:
      - build/install
  dependencies:
    - deb11_build

ubu20_user_install:
  stage: install
  needs: [ubu20_build]
  extends: .normal_job
  tags:
    - docker-executor
  image: $DOCKER_REGISTRY/sgl/ubuntu-20.04:pkgbuild
  script:
    - bash debian/install_required_deps_debian.sh package_ubuntu_20.04 pkg_min
    # source gnsstk's post install script to set private library install env variables.
    - source /usr/share/gnsstk*/gnsstk_post_install.sh
    - cd build
    - export gnsstk=`pwd`/install
    - cmake -DCMAKE_INSTALL_PREFIX=$gnsstk ../
    - make install -j 4
  artifacts:
    paths:
      - build/install
  dependencies:
    - ubu20_build

rhel8_user_install:
  stage: install
  needs: [rhel8_build]
  extends: .normal_job
  tags:
    - docker-executor
  image: $DOCKER_REGISTRY/sgl/centos-8:pkgbuild
  script:
    - bash rpm_files/install_required_deps_rpm.sh package_redhat_8 pkg_min
    - cd build
    - export gnsstk=`pwd`/install
    - cmake -DCMAKE_INSTALL_PREFIX=$gnsstk ../
    - make install -j 4
  artifacts:
    paths:
      - build/install
  dependencies:
    - rhel8_build

user_install_windows:
  stage: install
  variables:
    GIT_CLONE_PATH: $CI_BUILDS_DIR/$CI_PROJECT_NAME/$CI_PIPELINE_ID
    GIT_STRATEGY: none
  needs: [windows_build,windows_test]
  extends: .normal_job
  tags:
    - win10-vs2015
  script:
    - Get-ChildItem "$env:CI_PROJECT_DIR\library\build\install\share\cmake" -Directory | Foreach-Object { $env:CMAKE_PREFIX_PATH += ";" + $_.FullName }
    - cd build
    - cmake --build . --config Release --target install
  artifacts:
    paths:
      - build/install/
  dependencies:
    - windows_build
    - windows_test
  timeout: 20m
  allow_failure: false

user_install_windows_vs2019:
  stage: install
  variables:
    GIT_CLONE_PATH: $CI_BUILDS_DIR/$CI_PROJECT_NAME/${CI_PIPELINE_ID}_vs2019
    GIT_STRATEGY: none
  needs: [windows_build_vs2019,windows_test_vs2019]
  extends: .vs2019_job
  tags:
    - win10-vs2019
  script:
    - Get-ChildItem "$env:CI_PROJECT_DIR\library\build\install\share\cmake" -Directory | Foreach-Object { $env:CMAKE_PREFIX_PATH += ";" + $_.FullName }
    - cd build
    - cmake --build . --config Release --target install
  artifacts:
    paths:
      - build/install/
  dependencies:
    - windows_build_vs2019
    - windows_test_vs2019
  timeout: 20m
  allow_failure: false

user_install_windows_vs2019_dll:
  stage: install
  variables:
    GIT_CLONE_PATH: $CI_BUILDS_DIR/$CI_PROJECT_NAME/${CI_PIPELINE_ID}_vs2019_dll
    GIT_STRATEGY: none
  needs: [windows_build_vs2019_dll,windows_test_vs2019_dll]
  extends: .vs2019_dll_job
  tags:
    - win10-vs2019
  script:
    - Get-ChildItem "$env:CI_PROJECT_DIR\library\build\install\share\cmake" -Directory | Foreach-Object { $env:CMAKE_PREFIX_PATH += ";" + $_.FullName }
    - cd build
    - cmake --build . --config Release --target install
  artifacts:
    paths:
      - build/install/
  dependencies:
    - windows_build_vs2019_dll
    - windows_test_vs2019_dll
  timeout: 20m
  allow_failure: false

# user_install_windows_op1_vs2019: Moved to sgl-tks/ci-control/gnsstk-apps/ci_downstrm_chain.yml

# System Stage
# Tests install of GNSSTk on each platform, saves artifacts for downstream builds.
deb11_system_install:
  stage: install
  needs: [deb11_build]
  extends: .normal_job
  tags:
    - docker-executor
  image: $DOCKER_REGISTRY/sgl/debian-11:pkgbuild
  script:
    - bash debian/install_required_deps_debian.sh package_debian_11 pkg_min
    # source gnsstk's post install script to set private library install env variables.
    - source /usr/share/gnsstk*/gnsstk_post_install.sh
    - cd build
    - export gnsstk=/usr/local
    - cmake -DCMAKE_INSTALL_PREFIX=$gnsstk ../
    - make install -j 4
  dependencies:
    - deb11_build

ubu20_system_install:
  stage: install
  needs: [ubu20_build]
  extends: .normal_job
  tags:
    - docker-executor
  image: $DOCKER_REGISTRY/sgl/ubuntu-20.04:pkgbuild
  script:
    - bash debian/install_required_deps_debian.sh package_ubuntu_20.04 pkg_min
    # source gnsstk's post install script to set private library install env variables.
    - source /usr/share/gnsstk*/gnsstk_post_install.sh
    - cd build
    - export gnsstk=/usr/local
    - cmake -DCMAKE_INSTALL_PREFIX=$gnsstk ../
    - make install -j 4
  dependencies:
    - ubu20_build

rhel8_system_install:
  stage: install
  needs: [rhel8_build]
  extends: .normal_job
  tags:
    - docker-executor
  image: $DOCKER_REGISTRY/sgl/centos-8:pkgbuild
  script:
    - bash rpm_files/install_required_deps_rpm.sh package_redhat_8 pkg_min
    - cd build
    - export gnsstk=/usr/local
    - cmake -DCMAKE_INSTALL_PREFIX=$gnsstk ../
    - sudo make install -j 4
  dependencies:
    - rhel8_build


# Package Stage
# Tests packaging of GNSSTk-apps on all platforms
# Temporarily changing name back to old name so repo_utils can find this job.
# We will standardize job names per Jira SIM-55
#Temporarily changing name back to old name so repo_utils can find this job.  We will standardize job names per Jira SIM-55
package_debian_10:
  stage: package
  needs: []
  extends: .normal_job
  tags:
    - docker-executor
  image: $DOCKER_REGISTRY/sgl/debian-10:pkgbuild
  script:
    # kludge for dpkg
    - rm -f .gitmodules
    # Install dependencies from latest CI first.
    - bash debian/install_required_deps_debian.sh package_debian_10 pkg_min
    # source gnsstk's post install script to set private library install env variables.
    - source /usr/share/gnsstk*/gnsstk_post_install.sh
    # Remove any directories left over from the above script.
    - rm -rf packages
    # Mark the debian log so that this package is a backport.
    # Use the most recent Maintainer as current maintainer.
    - export DEBEMAIL=$(dpkg-parsechangelog -S Maintainer)
    - dch --bpo "No Changes"
    - dpkg-buildpackage -us -uc -d --changes-option="-DDistribution=buster-sgl"
    - mkdir debs
    - mv ../*.deb debs
    - mv ../*.changes debs
    - mv ../*.dsc debs
    - mv ../*.git ../*.gitshallow debs
    - mv ../*.buildinfo debs
  artifacts:
    paths:
      - debs/
  dependencies:
    - deb10_build

#Temporarily changing name back to old name so repo_utils can find this job.  We will standardize job names per Jira SIM-55
package_debian_11:
  stage: package
  needs: []
  extends: .normal_job
  tags:
    - docker-executor
  image: $DOCKER_REGISTRY/sgl/debian-11:pkgbuild
  script:
    # kludge for dpkg
    - rm -f .gitmodules
    # Install dependencies from latest CI first.
    - bash debian/install_required_deps_debian.sh package_debian_11 pkg_min
    # source gnsstk's post install script to set private library install env variables.
    - source /usr/share/gnsstk*/gnsstk_post_install.sh
    # Remove any directories left over from the above script.
    - rm -rf packages
    # Mark the debian log so that this package is a backport.
    # Use the most recent Maintainer as current maintainer.
    - export DEBEMAIL=$(dpkg-parsechangelog -S Maintainer)
    - dch --bpo "No Changes"
    - dpkg-buildpackage -us -uc -d --changes-option="-DDistribution=bullseye-sgl"
    - mkdir debs
    - mv ../*.deb debs
    - mv ../*.changes debs
    - mv ../*.dsc debs
    - mv ../*.git ../*.gitshallow debs
    - mv ../*.buildinfo debs
  artifacts:
    paths:
      - debs/

package_ubuntu_20.04:
  stage: package
  needs: []
  tags:
    - docker-executor
  image: $DOCKER_REGISTRY/sgl/ubuntu-20.04:pkgbuild
  script:
    # kludge for dpkg
    - rm -f .gitmodules
    # Install dependencies from latest CI first.
    - bash debian/install_required_deps_debian.sh package_ubuntu_20.04 pkg_min
    # source gnsstk's post install script to set private library install env variables.
    - source /usr/share/gnsstk*/gnsstk_post_install.sh
    # Remove any directories left over from the above script.
    - rm -rf packages
    # Mark the debian log so that this package is a backport.
    # Use the most recent Maintainer as current maintainer.
    - export DEBEMAIL=$(dpkg-parsechangelog -S Maintainer)
    - dch --bpo "No Changes" && dch  -l "ubuntu" -D focal 'No Changes' -u low
    - dpkg-buildpackage -us -uc -d --changes-option="-DDistribution=focal-sgl"
    - mkdir debs
    - mv ../*.deb debs
    - mv ../*.changes debs
    - mv ../*.dsc debs
    - mv ../*.git ../*.gitshallow debs
    - mv ../*.buildinfo debs
  artifacts:
    paths:
      - debs/
  dependencies:
    - ubu20_build

package_conda:
  stage: package
  needs: []
  extends: .normal_job
  tags:
    - docker-executor
  image: $DOCKER_REGISTRY/tks/centos-conda:python-3.6
  before_script:
    - source /opt/miniconda/etc/profile.d/conda.sh
  script:
    # Use of py3.9 package is arbitrary. Any of the gnsstk conda packages can be used for building
    # since gnsstk-apps does not depend on python.
    - bash conda_recipe/get_required_deps_conda.sh package_conda pkg_min
    - 'bash conda_recipe/get_required_deps_conda.sh "package_conda: [3.9]" pkg_min'
    - conda activate conda_builder
    - export GIT_COMMIT=$CI_COMMIT_REF_NAME
    - export GIT_LAST_TAG=$(git describe --abbrev=0 origin/stable)
    - export GIT_CHANGES_LAST_TAG=$(git rev-list --count $(git describe --abbrev=0 origin/stable)..@)
     # Output directory must exist before conda build
    - mkdir -p conda-bld
    - conda-build --output-folder conda-bld --python=$PYTHON_VERSION conda_recipe --override-channels -c file://$PWD/conda-deps/
    # Don't archive the cache files.
    - rm -r conda-bld/linux-64/.cache
  artifacts:
    paths:
      - conda-bld/linux-64/
  dependencies: []

package_redhat_8:
  stage: package
  needs: []
  extends: .normal_job
  tags:
    - docker-executor
  image: $DOCKER_REGISTRY/sgl/centos-8:pkgbuild
  script:
    - bash rpm_files/install_required_deps_rpm.sh package_redhat_8 pkg_min
    - bash rpm_files/setup_dirs.sh
    - git archive --prefix gnsstk-apps-master/ -o rpm_files/SOURCES/gnsstk-apps-master.tar.gz HEAD
    - pushd rpm_files
    - rpmbuild --define "_topdir ${PWD}" --define "debug_package %{nil}" --define "_build_id_links none" -ba SPECS/gnsstk-apps.spec
  artifacts:
    when: always
    paths:
     - rpm_files/RPMS/x86_64/gnsstk-*
     - rpm_files/SRPMS/gnsstk-*
  dependencies: []

package_windows:
  variables:
    GIT_CLONE_PATH: $CI_BUILDS_DIR/$CI_PROJECT_NAME/$CI_PIPELINE_ID
    GIT_STRATEGY: none
  stage: package
  needs: [windows_build]
  extends: .normal_job
  tags:
    - win10-vs2015
  script:
    - cd build
    - cpack -C Release
#    - cpack -G WIX -C Release
  dependencies:
    - windows_build
  artifacts:
    paths:
      - build/_CPack_Packages

package_windows_vs2019:
  variables:
    GIT_CLONE_PATH: $CI_BUILDS_DIR/$CI_PROJECT_NAME/${CI_PIPELINE_ID}_vs2019
    GIT_STRATEGY: none
  stage: package
  needs: [windows_build_vs2019]
  extends: .vs2019_job
  tags:
    - win10-vs2019
  script:
    - cd build
    - cpack -C Release
#    - cpack -G WIX -C Release
  dependencies:
    - windows_build_vs2019
  artifacts:
    paths:
      - build/_CPack_Packages

package_windows_vs2019_dll:
  variables:
    GIT_CLONE_PATH: $CI_BUILDS_DIR/$CI_PROJECT_NAME/${CI_PIPELINE_ID}_vs2019_dll
    GIT_STRATEGY: none
  stage: package
  needs: [windows_build_vs2019_dll]
  extends: .vs2019_dll_job
  tags:
    - win10-vs2019
  script:
    - cd build
    - cpack -C Release
#    - cpack -G WIX -C Release
  dependencies:
    - windows_build_vs2019_dll
  artifacts:
    paths:
      - build/_CPack_Packages

package_windows_op1_vs2019:
  variables:
    GIT_CLONE_PATH: $CI_BUILDS_DIR/$CI_PROJECT_NAME/${CI_PIPELINE_ID}_vs2019_op1
    GIT_STRATEGY: none
  stage: package
  needs: [windows_op1_build_vs2019]
  extends: .vs2019_job
  tags:
    - win10-vs2019
  script:
    - cd build
    - cpack -C Release
#    - cpack -G WIX -C Release
  dependencies:
    - windows_op1_build_vs2019
  artifacts:
    paths:
      - build/_CPack_Packages

package_windows_op1_vs2019_dll:
  variables:
    GIT_CLONE_PATH: $CI_BUILDS_DIR/$CI_PROJECT_NAME/${CI_PIPELINE_ID}_vs2019_dll_op1
    GIT_STRATEGY: none
  stage: package
  needs: [windows_op1_build_vs2019_dll]
  extends: .vs2019_dll_job
  tags:
    - win10-vs2019
  script:
    - cd build
    - cpack -C Release
#    - cpack -G WIX -C Release
  dependencies:
    - windows_op1_build_vs2019_dll
  artifacts:
    paths:
      - build/_CPack_Packages

# Deploy Stage
# Tests install of GNSSTk package on each platform, saves artifacts for downstream builds.
deb10_deploy:
  stage: deploy
  needs: [package_debian_10]
  extends: .package_deploy
  tags:
    - docker-executor
  image: $DOCKER_REGISTRY/sgl/debian-10:pkgbuild
  script:
    # Install dependencies from latest CI first.
    - bash debian/install_required_deps_debian.sh package_debian_10 pkg_min
    # source gnsstk's post install script to set private library install env variables.
    - source /usr/share/gnsstk*/gnsstk_post_install.sh
    - cd debs
    - sudo apt-get -y install ./*.deb
    - python3 -c "import gnsstk"
    - timeconvert
  dependencies:
    - package_debian_10

deb11_deploy:
  stage: deploy
  needs: [package_debian_11]
  extends: .package_deploy
  tags:
    - docker-executor
  image: $DOCKER_REGISTRY/sgl/debian-11:pkgbuild
  script:
    # Install dependencies from latest CI first.
    - bash debian/install_required_deps_debian.sh package_debian_11 pkg_min
    # source gnsstk's post install script to set private library install env variables.
    - source /usr/share/gnsstk*/gnsstk_post_install.sh
    - cd debs
    - apt-get -y install ./*.deb
    - python3 -c "import gnsstk"
    - timeconvert
  dependencies:
    - package_debian_11

ubu20_deploy:
  stage: deploy
  needs: [package_ubuntu_20.04]
  extends: .package_deploy
  tags:
    - docker-executor
  image: $DOCKER_REGISTRY/sgl/ubuntu-20.04:pkgbuild
  script:
    # Install dependencies from latest CI first.
    - bash debian/install_required_deps_debian.sh package_ubuntu_20.04 pkg_min
    # source gnsstk's post install script to set private library install env variables.
    - source /usr/share/gnsstk*/gnsstk_post_install.sh
    - cd debs
    - sudo apt-get -y install ./*.deb
    - python3 -c "import gnsstk"
    - timeconvert
  dependencies:
    - package_ubuntu_20.04

rhel8_deploy:
  stage: deploy
  needs: [package_redhat_8]
  extends: .package_deploy
  tags:
    - docker-executor
  image: $DOCKER_REGISTRY/sgl/centos-8:pkgbuild
  script:
    # Install dependencies from latest CI first.
    - bash rpm_files/install_required_deps_rpm.sh package_redhat_8 pkg_min
    - cd rpm_files/RPMS/x86_64/
    - sudo yum install gnsstk-*.rpm -y
    - timeconvert
  dependencies:
    - package_redhat_8

push_artifacts:
  extends: .push_selected_artifacts
  stage: push
  except:
    variables:
      - $BLD_ONLY_VS2019 == "True"
  variables:
    DEB_10_PACKAGES: "debs/*bpo10+1_amd64.deb"
    DEB_11_PACKAGES: "debs/*bpo11*.deb"
    UBU_20_PACKAGES: "debs/*bpo10+1ubuntu*.deb"
  needs: [package_conda, package_debian_10, package_debian_11, package_ubuntu_20.04, package_redhat_8]
  dependencies: [package_conda, package_debian_10, package_debian_11, package_ubuntu_20.04, package_redhat_8]

push_artifacts_windows:
  extends:
    - .push_selected_artifacts
    - .vs2019_job
  stage: push
  needs: [package_windows_vs2019]
  dependencies: [package_windows_vs2019]